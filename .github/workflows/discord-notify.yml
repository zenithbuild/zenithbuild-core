name: Discord Issue Notifications

on:
  issues:
    types: [opened, closed, reopened, edited, assigned, unassigned, labeled, unlabeled]
  issue_comment:
    types: [created]

# Security: Limit permissions to only what's needed
permissions:
  issues: write  # Needed to add labels to track notified issues
  contents: read

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Send to Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          set -e  # Exit on error
          set +x  # Don't echo commands (prevents secret exposure in logs)
          
          # Mask the webhook URL in logs to prevent accidental exposure
          echo "::add-mask::$DISCORD_WEBHOOK_URL"
          
          # Validate secret is set
          if [ -z "$DISCORD_WEBHOOK_URL" ]; then
            echo "‚ùå DISCORD_WEBHOOK_URL secret is not set"
            exit 1
          fi
          
          # Validate webhook URL format for security
          if [[ ! "$DISCORD_WEBHOOK_URL" =~ ^https://discord\.com/api/webhooks/[0-9]+/[A-Za-z0-9_-]+$ ]]; then
            echo "‚ùå Invalid Discord webhook URL format"
            exit 1
          fi
          
          # Get issue number and check if already notified
          ISSUE_NUMBER="${{ github.event.issue.number }}"
          REPO="${{ github.repository }}"
          TRACKING_LABEL="discord-notified"
          ACTION="${{ github.event.action }}"
          
          # Check if issue already has the tracking label (already notified)
          HAS_LABEL=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json labels --jq ".labels[] | select(.name == \"$TRACKING_LABEL\") | .name" 2>/dev/null || echo "")
          
          # Prevent duplicates based on event type
          case "$ACTION" in
            opened)
              # For new issues, skip if already notified
              if [ -n "$HAS_LABEL" ]; then
                echo "‚è≠Ô∏è  Issue #$ISSUE_NUMBER already notified to Discord, skipping..."
                exit 0
              fi
              ;;
            edited)
              # For edits: if not notified yet, treat as initial notification (for backfilling)
              # If already notified, send update notification
              if [ -z "$HAS_LABEL" ]; then
                echo "‚ÑπÔ∏è  Issue #$ISSUE_NUMBER hasn't been initially notified yet, treating edit as initial notification..."
                # Change action to "opened" for initial notification formatting
                ACTION="opened"
              fi
              ;;
            assigned|unassigned|labeled|unlabeled)
              # For other updates, only send if issue was already notified (initial notification sent)
              if [ -z "$HAS_LABEL" ]; then
                echo "‚è≠Ô∏è  Issue #$ISSUE_NUMBER hasn't been initially notified yet, skipping update notification..."
                exit 0
              fi
              ;;
            closed|reopened)
              # Always send for state changes (closed/reopened) - these are important
              # But skip if issue was never initially notified
              if [ -z "$HAS_LABEL" ]; then
                echo "‚è≠Ô∏è  Issue #$ISSUE_NUMBER hasn't been initially notified yet, skipping state change notification..."
                exit 0
              fi
              ;;
          esac
          
          # Determine color, emoji, and title based on action (ACTION already set above)
          case "$ACTION" in
            opened)
              COLOR="3066993"  # Green
              EMOJI="üìù"
              TITLE="New Issue Created"
              ;;
            closed)
              COLOR="15158332"  # Red
              EMOJI="‚úÖ"
              TITLE="Issue Closed"
              ;;
            reopened)
              COLOR="15105570"  # Orange
              EMOJI="üîÑ"
              TITLE="Issue Reopened"
              ;;
            edited)
              COLOR="3447003"  # Blue
              EMOJI="‚úèÔ∏è"
              TITLE="Issue Edited"
              ;;
            assigned|unassigned)
              COLOR="10181046"  # Purple
              EMOJI="üë§"
              TITLE="Issue Assignment Changed"
              ;;
            labeled|unlabeled)
              COLOR="15844367"  # Gold
              EMOJI="üè∑Ô∏è"
              TITLE="Issue Label Changed"
              ;;
            *)
              COLOR="3447003"  # Blue
              EMOJI="üìã"
              TITLE="Issue Updated"
              ;;
          esac
          
          # Export variables for Node.js script
          export EMOJI TITLE COLOR
          
          # Use Node.js to properly build JSON payload with escaping
          # Write Node.js script to temp file (no quotes on heredoc to allow GitHub Actions expansion)
          cat > /tmp/discord_payload.js <<JS_EOF
          const issue = ${{ toJSON(github.event.issue) }};
          const repo = "${{ github.repository }}";
          const emoji = process.env.EMOJI || 'üìã';
          const title = process.env.TITLE || 'Issue Updated';
          const color = parseInt(process.env.COLOR || '3447003', 10);
          
          // Format labels - use string concatenation to avoid template literal issues
          const labels = issue.labels && issue.labels.length > 0
            ? issue.labels.map(function(l) { return String.fromCharCode(96) + l.name + String.fromCharCode(96); }).join(' ')
            : '*No labels*';
          
          // Truncate body
          let body = issue.body || '*No description*';
          if (body.length > 1000) {
            body = body.substring(0, 1000) + '...';
          }
          
          // Build embed
          const embed = {
            title: emoji + ' ' + title,
            description: '**' + issue.title + '**',
            url: issue.html_url,
            color: color,
            fields: [
              {
                name: 'Issue #',
                value: '#' + issue.number,
                inline: true
              },
              {
                name: 'State',
                value: issue.state,
                inline: true
              },
              {
                name: 'Labels',
                value: labels,
                inline: false
              },
              {
                name: 'Description',
                value: body,
                inline: false
              }
            ],
            author: {
              name: issue.user.login,
              icon_url: issue.user.avatar_url
            },
            footer: {
              text: repo
            },
            timestamp: new Date().toISOString()
          };
          
          console.log(JSON.stringify({ embeds: [embed] }));
          JS_EOF
          
          # Run the Node.js script
          PAYLOAD=$(node /tmp/discord_payload.js)
          
          # Send to Discord with error handling
          HTTP_CODE=$(curl -s -o /tmp/discord_response.txt -w "%{http_code}" \
            -X POST "$DISCORD_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          
          # Check response
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "‚úÖ Successfully sent notification to Discord"
            
            # Mark issue as notified by adding label (for "opened" events or initial "edited" notifications)
            # This prevents duplicate initial notifications
            if [ "$ACTION" = "opened" ] || [ -z "$HAS_LABEL" ]; then
              # Check if label exists, create if not
              LABEL_EXISTS=$(gh label list --repo "$REPO" --json name --jq ".[] | select(.name == \"$TRACKING_LABEL\") | .name" 2>/dev/null || echo "")
              
              if [ -z "$LABEL_EXISTS" ]; then
                echo "Creating tracking label: $TRACKING_LABEL"
                gh label create "$TRACKING_LABEL" \
                  --repo "$REPO" \
                  --color "0E8A16" \
                  --description "Issue has been notified to Discord" \
                  2>/dev/null || true
              fi
              
              # Add label to issue to mark as notified
              echo "Marking issue #$ISSUE_NUMBER as notified"
              gh issue edit "$ISSUE_NUMBER" \
                --repo "$REPO" \
                --add-label "$TRACKING_LABEL" \
                2>/dev/null || echo "‚ö†Ô∏è  Could not add label (may already exist)"
            fi
          else
            echo "‚ùå Failed to send notification (HTTP $HTTP_CODE)"
            # Log error response without exposing webhook URL
            if [ -f /tmp/discord_response.txt ]; then
              echo "Response: $(cat /tmp/discord_response.txt)"
            fi
            exit 1
          fi
          
          # Clean up
          rm -f /tmp/discord_response.txt /tmp/discord_payload.js

